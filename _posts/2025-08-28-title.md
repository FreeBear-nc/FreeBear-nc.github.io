---
title: "Bison, Bisonc++, and Antlr4"
date: 2025-08-28
---

Looking at using a parser generator to produce code to process arithmetic expressions. The intention is (was) to perhaps extend it to evaluate expressions and return jump points.<br>

Three important factors:
-  Runtime code needs to have a suitable permissive licence.
-  Generated code must be compact and compile to a minimal binary.
-  Should be simple to integrate in to the existing tokenising code.<br>

  Must also be reentrant and not use any global variables.

## [Bisonc++](https://fbb-git.gitlab.io/bisoncpp/)
-  A relatively small package at 238K for the deb (install size 880K).
-  Compatible with Bison grammar for the most part.
-  Generates standalone code that doesn't require any supporting libraries.
-  Easy to integrate with the existing tokeniser.
-  Generated code is subject to to GPL licencing terms.
-  A simple calculator example generates a stripped ~125K binary.

## Bison (C++ version)
-  Package size is a little larger than BisonC++ at 329K, although install size is less (535K).
-  As the reference point for grammar compatibility, no further comment required.
-  Although Bison++ is GPL, there is an exception for generated code. So in theory, an alternative licence could be used.
-  Slightly more involved to integrate with the existing codebase, but nothing too taxing.
-  Again, standalone code that doesn't require any runtime libraries.
-  Stripped test calculator is ~90K.

## Antlr4
-  BSD licence (probably applies to generated code).
-  Requires a 347K runtime package (~1.3M installed).
-  To generate the parser code requires some 25M or more - The price one pays for using Java.
-  Even stripped to the minimum and compiled without any debugging, the basic test binary weighs in at some 850K
-  On that basis alone, Antlr4 can be dismissed.

### Further work
Need to compare actual execution speeds and compare to a hand written parser - Gut feeling is the hand written version will be faster at the expense of maintainability and ease of extending.
That said, don't need any complex functionality from the parser. For the arithmetic side, just return a single number. Expression evaluation only needs to return true/false,
and the execution routines can decide the final jump point.
  
